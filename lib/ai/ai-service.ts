import { createClient } from '@supabase/supabase-js'
import { Database } from '@/types/supabase'

// Create a server-side Supabase client
const supabaseServer = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)

// Fetch all AI assistants
export async function getAIAssistants() {
  const { data, error } = await supabaseServer.from("ai_assistants").select("*").order("created_at", { ascending: false })

  if (error) {
    console.error("Error fetching AI assistants:", error)
    throw error
  }

  return data
}

// Fetch a single AI assistant by ID
export async function getAIAssistant(id: string) {
  const { data, error } = await supabaseServer.from("ai_assistants").select("*").eq("id", id).single()

  if (error) {
    console.error(`Error fetching AI assistant with ID ${id}:`, error)
    throw error
  }

  return data
}

// Create a new AI assistant
export async function createAIAssistant(assistantData: any) {
  const { data, error } = await supabaseServer
    .from("ai_assistants")
    .insert({
      name: assistantData.name,
      role: assistantData.role,
      description: assistantData.description,
      personality: assistantData.personality,
      status: assistantData.status,
      behavior_settings: assistantData.behavior_settings || {},
      knowledge_sources: assistantData.knowledge_sources || {},
      human_intervention_settings: assistantData.human_intervention_settings || {},
    })
    .select()
    .single()

  if (error) {
    console.error("Error creating AI assistant:", error)
    throw error
  }

  return data
}

// Update an existing AI assistant
export async function updateAIAssistant(id: string, assistantData: any) {
  const { data, error } = await supabaseServer
    .from("ai_assistants")
    .update({
      name: assistantData.name,
      role: assistantData.role,
      description: assistantData.description,
      personality: assistantData.personality,
      status: assistantData.status,
      behavior_settings: assistantData.behavior_settings || {},
      knowledge_sources: assistantData.knowledge_sources || {},
      human_intervention_settings: assistantData.human_intervention_settings || {},
      updated_at: new Date().toISOString(),
    })
    .eq("id", id)
    .select()
    .single()

  if (error) {
    console.error(`Error updating AI assistant with ID ${id}:`, error)
    throw error
  }

  return data
}

// Delete an AI assistant
export async function deleteAIAssistant(id: string) {
  const { error } = await supabaseServer.from("ai_assistants").delete().eq("id", id)

  if (error) {
    console.error(`Error deleting AI assistant with ID ${id}:`, error)
    throw error
  }

  return true
}

// Generate a response from an AI assistant
export async function generateAIResponse(assistantId: string, message: string, conversationId?: string | null) {
  if (!assistantId) {
    throw new Error("Assistant ID is required")
  }

  // If no conversation ID is provided, create a new conversation
  let currentConversationId = conversationId
  if (!currentConversationId) {
    const conversation = await saveConversation(assistantId)
    if (!conversation?.id) {
      throw new Error("Failed to create conversation")
    }
    currentConversationId = conversation.id
  }

  // Type guard to ensure currentConversationId is a string
  if (typeof currentConversationId !== 'string') {
    throw new Error("Invalid conversation ID")
  }

  // Save the user message
  await saveMessage(currentConversationId, "user", message)

  // Generate a response
  // In a real implementation, this would use the AI SDK to generate a response
  // For now, we'll just return a mock response
  const mockResponse = `This is a mock response to: "${message}"\n\nIn a real implementation, this would be generated by an AI model using the documents and knowledge sources associated with this assistant.`

  // Save the assistant message
  await saveMessage(currentConversationId, "assistant", mockResponse)

  return {
    response: mockResponse,
    conversationId: currentConversationId,
    messageId: `mock-message-id-${Date.now()}`,
  }
}

// Generate a response from an AI assistant
export async function generateAssistantResponse(assistantId: string, message: string, conversationHistory?: any) {
  // This is a placeholder for the actual AI response generation
  // In a real implementation, this would call an AI service like OpenAI

  // For now, we'll just return a mock response
  return {
    response: `This is a mock response to: "${message}"`,
    conversationId: "new-conversation-id",
    messageId: "mock-message-id",
  }
}

// Save a conversation
export async function saveConversation(assistantId: string, metadata: any = {}) {
  const { data, error } = await supabaseClient
    .from("conversations")
    .insert({
      assistant_id: assistantId,
      metadata,
    })
    .select()
    .single()

  if (error) {
    console.error("Error saving conversation:", error)
    throw error
  }

  return data
}

// Save a message in a conversation
export async function saveMessage(conversationId: string, role: string, content: string, metadata: any = {}) {
  const { data, error } = await supabaseClient
    .from("messages")
    .insert({
      conversation_id: conversationId,
      role,
      content,
      metadata,
    })
    .select()
    .single()

  if (error) {
    console.error("Error saving message:", error)
    throw error
  }

  return data
}
